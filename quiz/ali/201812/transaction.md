### [事务][]
+ 背景
+ 关系型数据库的事务
+ redis的事务
+ 分布式事务
+ spring中的事务机制

#### 一. 背景（事务的定义）
事务的定义：用户定义的一个数据库操作序列，是一个不可分割的单元，要么全部成功，要么全部失败。

#### 二. 关系型数据库的事务

##### 事务特点
1. 原子性：事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行
1. 一致性: 一致性要求，事务在开始前和结束后，数据库的完整性约束没有被破坏
1. 隔离性: 事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据
1. 持久性: 一个事务完成之后，事务的执行结果必须是持久化保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失

##### 事务并发时，可能出现的问题
1. 更新丢失：当有两个并发执行的事务，更新同一行数据，那么有可能一个事务会把另一个事务的更新覆盖掉。 当数据库没有加任何锁操作的情况下会发生
1. 赃读：一个事务读到另一个尚未提交的事务中的数据。 该数据可能会被回滚从而失效。 如果第一个事务拿着失效的数据去处理那就发生错误了
1. 不可重复读：一个事务对同一行数据读了两次，却得到了不同的结果。它具体分为如下两种情况
> 1. 虚读：在事务1两次读取同一记录的过程中，事务2对该记录进行了修改，从而事务1第二次读到了不一样的记录
> 1. 幻读：事务1在两次查询的过程中，事务2对该表进行了插入、删除操作，从而事务1第二次查询的结果发生了变化

##### 事务隔离级别：
1. 未提交读：在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。 因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读
1. 提交读：在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况
1. 可重复读：在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务
1. 序列化读：该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低

##### 隔离级别的实现：
+ 悲观锁：用于数据的新增、添加、删除
+ 乐观锁：用户数据的读取操作

1. 未提交读：并发时，未加锁
1. 提交读：并发时，对写操作加悲观锁，读操作不加锁，所以读操作的数据可以被写操作更新
1. 可重复读：并发时，对写操作加悲观锁，读操作加乐观锁，所以读操作可以读取 本事务版本之前的数据、以及删除版本号>当前事务版本的数据
    >+ SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
    >+ INSERT时，保存当前事务版本号为行的创建版本号
    >+ DELETE时，保存当前事务版本号为行的删除版本号
    >+ UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行
    
    > 为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。
    > Next-Key锁是行锁和GAP（间隙锁）的合并，不仅用行锁，锁住了相应的数据行；同时也在行索引值两边的区间，都加入了gap锁
    
1. 序列化读：对表加锁（表锁），读是共享锁，写是排它锁，且读写互斥，所有事务串行执行


#### 三. [redis事务][]
##### 事务相关命令
+ MULTI: 开启一个事务，MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令, 这些命令不会立即被执行, 而是被放到一个队列中
+ EXEC: 负责触发并执行事务中的所有命令 
+ DISCARD: 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出
+ WATCH: 被WATCH的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败  

##### 事务中的错误
使用事务时可能会遇上以下两种错误：
>+ 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。
>+ 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类

对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务  

在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行  

#### 四. 分布式事务
##### 定义
在数据库之上通过某种手段，实现支持跨数据库的事务支持，这也就是大家常说的“分布式事务”

##### CAP理论
CAP理论说的是：在一个分布式系统中，最多只能满足C、A、P中的两个需求。  

CAP的含义：

>+ C：Consistency 一致性, 同一数据的多个副本是否实时相同。
>+ A：Availability 可用性, 可用性：一定时间内 & 系统返回一个明确的结果 则称为该系统可用。
>+ P：Partition tolerance 分区容错性, 将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。


##### BASE理论
对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性, 所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲强一致性换取弱一致性  

BASE理论

>+ BA：Basic Available 基本可用  
    整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是：  
    
  >>. “一定时间”可以适当延长
  >>1. 当举行大促时，响应时间可以适当延长
  >>1. 给部分用户返回一个降级页面
  >>1. 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。

>+ S：Soft State：柔性状态, 同一数据的不同副本的状态，可以不需要实时一致。
>+ E：Eventual Consisstency：最终一致性, 同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的

##### 酸碱平衡
根据具体业务场景，在ACID和BASE之间寻求平衡。


##### 分布式事务协议

###### 两阶段提交协议 2PC
分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：
+ 该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。
+ 所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。
+ 所有节点不会永久性损坏，即使损坏后仍然可以恢复。  

第一阶段（投票阶段）：
1. 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
1. 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
1. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息。

第二阶段（提交执行阶段）：
当协调者节点从所有参与者节点获得的相应消息都为"同意"时：
1. 协调者节点向所有参与者节点发出"正式提交(commit)"的请求。
1. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
1. 参与者节点向协调者节点发送"完成"消息。
1. 协调者节点受到所有参与者节点反馈的"完成"消息后，完成事务。

如果任一参与者节点在第一阶段返回的响应消息为"中止"，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
1. 协调者节点向所有参与者节点发出"回滚操作(rollback)"的请求。
1. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
1. 参与者节点向协调者节点发送"回滚完成"消息。
1. 协调者节点受到所有参与者节点反馈的"回滚完成"消息后，取消事务

二阶段提交还是有几个缺点的：
1. 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
1. 参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）
1. 协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）
1. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交

###### 三阶段提交协议 3PC
与两阶段提交不同的是，三阶段提交有两个改动点。
+ 引入超时机制。同时在协调者和参与者中都引入超时机制。
+ 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段

1. CanCommit阶段
    > 3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
    >+ 事务询问, 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
    >+ 响应反馈, 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No

1. PreCommit阶段
    协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。
    
    > 假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。
    >+ 发送预提交请求, 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
    >+ 事务预提交, 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
    >+ 响应反馈, 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

    > 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
    >+ 发送中断请求, 协调者向所有参与者发送abort请求。
    >+ 中断事务, 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

1. doCommit阶段
    该阶段进行真正的事务提交，也可以分为以下两种情况。
    
    > 1. 执行提交
    >+  发送提交请求, 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
    >+ 事务提交, 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
    >+ 响应反馈, 事务提交完之后，向协调者发送Ack响应。
    >+ 完成事务, 协调者接收到所有参与者的ack响应之后，完成事务。

    > 2. 中断事务  协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。
    >+ 发送中断请求, 协调者向所有参与者发送abort请求
    >+ 事务回滚, 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
    >+ 反馈结果, 参与者完成事务回滚之后，向协调者发送ACK消息
    >+ 中断事务, 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。


##### 分布式事务的解决方案
分布式事务的解决方案有如下几种：
+ 全局消息
+ 基于可靠消息服务的分布式事务
+ TCC
+ 最大努力通知

###### 基于可靠消息服务的分布式事务
这种实现分布式事务的方式需要通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理

+ 在系统A处理任务A前，首先向消息中间件发送一条消息
+ 消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。
+ 消息中间件持久化成功后，便向系统A返回一个确认应答；
+ 系统A收到确认应答后，则可以开始处理任务A；
+ 任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。
+ 但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。
+ 消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；
+ 当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成



#### 五. spring中的事务机制(@Transactional)

##### [Spring 事务的传播属性][1]
所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表:  

常量名称    |   常量解释
--- | ---   
PROPAGATION_REQUIRED        |	支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。
PROPAGATION_REQUIRES_NEW    |	新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作
PROPAGATION_SUPPORTS        |	支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY       |	支持当前事务，如果当前没有事务，就抛出异常。
PROPAGATION_NOT_SUPPORTED   |	以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER	        |   以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED	        |   如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。

##### Spring中的隔离级别

常量  |	解释
--- |   ---
ISOLATION_DEFAULT           |	这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。
ISOLATION_READ_UNCOMMITTED  |	这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。
ISOLATION_READ_COMMITTED    |	保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。
ISOLATION_REPEATABLE_READ   |   这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。
ISOLATION_SERIALIZABLE      |	这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。


##### 事务的嵌套

假设外层事务 Service A 的 Method A() 调用 内层Service B 的 Method B()

+. PROPAGATION_REQUIRED(spring 默认)

    如果ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候spring已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运行在 ServiceA.methodA() 的事务内部，就不再起新的事务。
    假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。
    这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。

+. PROPAGATION_REQUIRES_NEW

    比如我们设计 ServiceA.methodA() 的事务级别为 PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。
    那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起，ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。
    他与 PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为 ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。如果 ServiceB.methodB() 失败回滚，如果他抛出的异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看B抛出的异常是不是A会回滚的异常)。

+. PROPAGATION_SUPPORTS

    假设ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.methodB()时，如果发现ServiceA.methodA()已经开启了一个事务，则加入当前的事务，如果发现ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。

+. PROPAGATION_NESTED

    现在的情况就变得比较复杂了, ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时两者之间又将如何协作呢?  ServiceB#methodB 如果 rollback, 那么内部事务(即 ServiceB#methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA#methodA) 可以有以下两种处理方式:
    
    a、捕获异常，执行异常分支逻辑
    
    `void methodA() { 
    
            try { 
    
                ServiceB.methodB(); 
    
            } catch (SomeException) { 
    
                // 执行其他业务, 如 ServiceC.methodC(); 
    
            } 
    
        }`
    这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。
    
    b、 外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB#methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback



[//]: 参考链接

 
[事务隔离级别和锁的关系]: https://tech.meituan.com/innodb_lock.html 
[事务]: https://juejin.im/post/5aa3c7736fb9a028bb189bca
[分布式事务一致性]: https://yq.aliyun.com/articles/582282
[redis事务]: http://redis.cn/topics/transactions.html
[Spring事务原理]: https://www.jianshu.com/p/42ce0f9250f5
[1]: https://www.jianshu.com/p/4312162b1458
