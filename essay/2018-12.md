### 2018-12-16 周日 晴

#### Java并发中的Synchronized相关的锁

#### 背景
> + Synchronized是通过对象内部一个叫**监视器锁**（monitor）来实现的。   
> + 但是监视器锁，其本质是依赖于底层的操作系统的Mutex Lock实现的。  
> + 而操作系统实现线程之间的切换，需要从用户态转换到内核态，这个成本非常高，  
    状态之间的转换需要相对比较长的时间。这就是Synchronized效率低的原因。
> + 因此，这种依赖于操作系统的Mutex Lock实现的锁，称之为“重量级锁”。
> + 为了减少获取锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。

#### jvm锁的状态
+ 无锁状态
+ 偏向锁状态
+ 轻量级锁状态
+ 重量级锁状态

##### 偏向锁
+ 使用场景： 只有**一个线程**执行同步代码块，偏向与首次获取锁的线程

+ 偏向锁获取过程：（jvm默认开启偏向锁，即锁对象起始 是否是偏向锁位 是1 ）  
 
> 1. 访问锁对象的Mark Word中的**偏向锁标识**是否为1、 **锁标志位**是否为01， 确认为可偏向状态
> 1. 若为可偏向状态，检查锁对象Mark Word的threadId是否是当前线程，是则步骤5，不是则步骤3
> 1. CAS设置锁对象Mark Word的ThreadId为当前线程，成功则步骤5，失败则步骤4
> 1. 若CAS失败，说明有锁竞争。当到达全局安全点时，获得偏向锁的线程被挂起，锁升级为轻量级锁，然后被挂起的线程步骤5
> 1. 执行同步代码

+ 偏向锁释放：
> + 只有在其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。
> + 偏向锁的撤销，需要等到全局安全点（在这个时间点没有字节码在执行）。
> + 首先暂停拥有偏向锁的线程
> + 若持有偏向锁的线程，处于不活动状态，将锁对象设置为无锁状态
> + 若持有偏向锁的线程，仍然活着，将锁对象升级为轻量级锁
> + 唤醒暂停的线程

##### 轻量级锁
+ 使用场景：线程交替执行同步快的情况

+ 轻量级锁获取过程： 无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”） 

> 1. 对象锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝
> 1. 拷贝对象头中的Mark Word复制到锁记录中
> 1. CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。
>    如果更新成功，则执行步骤（3），否则执行步骤（4）
> 1. 更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态
> 1. 更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，
>    那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程

+ 轻量级锁的解锁过程

> 1. 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word
> 1. 如果替换成功，整个同步过程就完成了
> 1. 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程


##### 轻量级锁
+ 使用场景：同一时间访问同一锁的情况


