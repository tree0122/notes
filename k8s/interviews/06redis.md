1. 项目中redis的应用场景（4m）
    1. 5大value类型：string、list、set、zset、hash
    1. 基本上就是缓存
    1. 为的是服务无状态，单机锁、分布式锁
    1. 无锁化
1. Set、Zset 分别用于哪些场景？（10m）
1. redis是单线程还是多线程？（10m）
    1. 无论什么版本，工作线程就是一个
    1. 6.x高版本出现IO多线程
    1. 使用上来说，无变化
    1. 【系统io课】面向io编程时，有内核的事，从内核把数据搬运到程序里（第一步），然后 搬运回来的数据做计算（第二部），netty（reactor）
    1. 单线程，满足redis的串行原子，只不过io多线程后，把io放到更多线程去并行，好处如下：执行时间更快、更好压榨系统及硬件资源
    1. 客户端被读取的顺序不能被保障，在一个socket里的顺序可保障
1. redis存在线程安全问题妈？为什么？（41m）
    重复2中的单线程串行

    redis可保障内部串行

    外界使用时要保障，业务上自行保障顺序
1. 缓存穿透？详细描述一下？
    穿透：db中没有对应数据

    解决：
    1. null key
    1. 布隆过滤器
    1. 分布式锁
1. 缓存击穿？详细描述一下？
    击穿：某一热点key过期（未被缓存的热点数据）。db有，大量并发，未被缓存

    解决：
    1. 不知道请求是不是并发
    1. 保障db压力，有效请求
    1. 请求redis，肯定没有
    1. 抢锁，抢到锁的查db，否则sleep、或者服务治理
    1. db，更新redis
    1. sleep的回到第一步
1. 如何避免缓存雪崩？（69m）
    雪崩：多个热点key未被缓存，击穿算是其子集

1. 缓存如何回收？（92m）
    1. 后台的轮询，分段分批的删除哪些过期的key
    1. 请求的时候判断是否过期

1. 缓存如何回收？（96m）
    内存空间不足的情况下：
    1. 淘汰机制里有不允许淘汰
    1. lru/lfu/random/ttl
    1. 全空间
    1. 设置过期的key的集合中

1. 缓存如何预热？（99）
    1. 提前把数据放入redis
    1. 是否有击穿问题？

1. db和缓存不一致如何解决？（102m）
    1. 分布式事务（意义不大，最多读多写稀有）
    1. redis是缓存，更倾向于稍微的时差
    1. 还是减少db的操作（三大问题）
    1. 真的要落地，还是cannal
1. 主从不一致问题？（128m）
    1. 弱一致性，异步的同步
    1. 锁不能用主从（单例/分片集群/）=》redisson
    1. 在配置中提供里必须多少个client连接能同步，配置同步因子，趋向于强一致性
    1. wait 2 0（小心），有些违背redis的初衷
1. redis持久化原理（132m）
    当前线程阻塞服务   
    异步后台进程完成持久   
    fork + cow
1. redis也扛不住了，万级流量打到db，该怎么处理？
    详见 4 5 6
1. 持久化方式
    1. rdb、aof，主从同步也算持久化
    1. 高版本：开启aof，aof可通过执行日志得到全部内存数据的方式，但是追求性能
        1. 体积变大，重复无效指令。重写，后台用线程把内存的kv生成的指令写给新的aof
        1. 4.x版本，把重写方式换成直接rdb，放到aof文件的头部，再追加日志
